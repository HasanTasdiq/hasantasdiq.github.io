


















<!DOCTYPE html>
<html lang='en-us'><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <link rel="shortcut icon" href='http://localhost:1313/favicon.ico' type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>RL Notes: Huggin Face RL Course - Tasdiqul Islam</title>

    

    

    
    <meta name="author" content="Your Name" />
    

    
        <meta property="og:url" content="http://localhost:1313/posts/hfrl-1/">
  <meta property="og:site_name" content="Tasdiqul Islam">
  <meta property="og:title" content="RL Notes: Huggin Face RL Course">
  <meta property="og:description" content="HFRL Unit-1 Summary Reinforcement Learning is a method where an agent learns by interacting with its environment, using trial and error and feedback from rewards.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-10-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-10-10T00:00:00+00:00">
    <meta property="article:tag" content="RL">
    <meta property="article:tag" content="Neural Network">
    <meta property="article:tag" content="Machine Learning">
    <meta property="article:tag" content="AI">
    <meta property="article:tag" content="Hugging Face">

    

    
        
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="RL Notes: Huggin Face RL Course">
  <meta name="twitter:description" content="HFRL Unit-1 Summary Reinforcement Learning is a method where an agent learns by interacting with its environment, using trial and error and feedback from rewards.">

    <link rel="stylesheet" href="/style.css" integrity="">





    
    <script>
        if (!('theme' in localStorage)) {
            localStorage.theme = 'light';
        }

        if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.setAttribute("data-theme", "dark");
        } else {
            document.documentElement.setAttribute("data-theme", "light");
        }
    </script>
<script defer src="/js/theme-switch.js" integrity=""></script>



    <script defer src="/js/hide-navbar-on-scroll.js" integrity=""></script>





    <script defer src="/js/zooming.js" integrity=""></script>




    <script src="/js/math.js" integrity=""></script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@4.0.0-beta.3/tex-mml-chtml.js"></script>











    
</head>
<body><header>
    <div id="header_content">
        <div id="header_left">
            <div id="sidebar_btn">
                <input type="checkbox" id="sidebar_btn_input" class="hidden" />
                <label id="sidebar_btn_label" for="sidebar_btn_input">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1.5rem" height="1.5rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line>
</svg>

</label>
                <label id="sidebar_canvas_overlay_wrapper" for="sidebar_btn_input">
                    <div id="sidebar_canvas_overlay"></div>
                </label>
                <div id="sidebar">
                    <ul><li>
                                <a href="/about/">About Me</a></li><li>
                                <a href="/research/">Research</a></li><li>
                                <a href="/publications/">Publications</a></li><li>
                                <a href="/posts/">Bits, Bytes &amp; Life</a></li></ul>
                </div>
            </div>
        
            <div class="brand">
                <div>
                    <a href="/">Tasdiqul Islam</a>
                </div>
            </div><nav id="header_navbar" class="pure-menu header-menu">
    <ul class="pure-menu-list"><li class="header-menu-item pure-menu-item ">
                    
                        <a href="/about/" class="pure-menu-link">About Me</a>
                    
                </li><li class="header-menu-item pure-menu-item ">
                    
                        <a href="/research/" class="pure-menu-link">Research</a>
                    
                </li><li class="header-menu-item pure-menu-item ">
                    
                        <a href="/publications/" class="pure-menu-link">Publications</a>
                    
                </li><li class="header-menu-item pure-menu-item insection">
                    
                        <a href="/posts/" class="pure-menu-link">Bits, Bytes &amp; Life</a>
                    
                </li></ul>
</nav>
</div>

        <div id="header_right">
            

            <div id="theme_tool">
                <button id="dark_mode_btn" class="header-menu-btn outline-button" title='Switch to dark mode' type="button">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1.5rem" height="1.5rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
</svg>

</button>
                <button id="light_mode_btn" class="header-menu-btn outline-button" title='Switch to light mode' type="button">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1.5rem" height="1.5rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
</svg>

</button>
            </div>

            
        </div>
    </div>
</header><div id="search_menu_wrapper" class="hidden">
    <div id="search_menu">
        <div id="search_menu_toolbar">
            <div id="search_menu_input_wrapper">
                <input id="search_menu_input" type="text" placeholder='Search Posts'>
            </div>
            <div id="search_menu_close_btn">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1.25rem" height="1.25rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line>
</svg>

</div>
        </div>
        <div id="search_menu_results">
        </div>
    </div>
</div>
<main>
            <div id="content" class="content-margin">
                
    
    
        
        <div class="collapsible-menu-wrapper"><div class="collapsible-menu-type"><span>Table of contents</span></div><div class="collapsible-menu">
        
            <nav id="TableOfContents">
  <ul>
    <li><a href="#hfrl-unit-1">HFRL Unit-1</a>
      <ul>
        <li><a href="#summary">Summary</a></li>
        <li><a href="#two-ways-to-find-optimal-policy">Two ways to find Optimal Policy</a></li>
      </ul>
    </li>
    <li><a href="#hfrl-unit-2">HFRL Unit-2</a>
      <ul>
        <li><a href="#value-based-methods">Value-based methods</a></li>
        <li><a href="#bellman-equations">Bellman Equations</a></li>
        <li><a href="#monte-carlo-methods">Monte Carlo Methods</a></li>
        <li><a href="#temporal-difference-td-learning">Temporal Difference (TD) Learning</a></li>
        <li><a href="#on-policy-vs-off-policy-learning">On-policy vs Off-policy Learning</a></li>
        <li><a href="#q-learning">Q-learning</a></li>
        <li><a href="#q-learning-algorithm">Q-learning Algorithm</a></li>
        <li><a href="#off-policy-vs-on-policy">Off-policy vs On-policy</a></li>
      </ul>
    </li>
    <li><a href="#hfrl-unit-3">HFRL Unit-3</a>
      <ul>
        <li><a href="#q-function-recap">Q-Function Recap</a></li>
        <li><a href="#deep-q-networks-dqn">Deep Q-Networks (DQN)</a></li>
        <li><a href="#preprocessing-the-input-and-temporal-limits">Preprocessing the Input and Temporal Limits</a></li>
        <li><a href="#the-deep-q-learning-algorithm">The Deep Q-Learning Algorithm</a></li>
      </ul>
    </li>
    <li><a href="#hfrl-unit-4">HFRL Unit-4</a>
      <ul>
        <li><a href="#policy-based-methods">Policy-based Methods</a></li>
        <li><a href="#the-difference-between-policy-based-and-policy-gradient-methods">The difference between Policy-based and policy-gradient methods</a></li>
        <li><a href="#policy-gradient-methods">Policy Gradient Methods</a></li>
      </ul>
    </li>
    <li><a href="#hfrl-unit-5">HFRL Unit-5</a></li>
    <li><a href="#hfrl-unit-6">HFRL Unit-6</a>
      <ul>
        <li><a href="#the-problem-of-high-variance-in-reinforce">The Problem of High Variance in REINFORCE</a></li>
        <li><a href="#advantage-actor-critic-a2c">Advantage Actor-Critic (A2C)</a></li>
      </ul>
    </li>
    <li><a href="#hfrl-unit-7">HFRL Unit-7</a></li>
    <li><a href="#hfrl-unit-8">HFRL Unit-8</a>
      <ul>
        <li><a href="#the-intuition-behind-ppo">The Intuition Behind PPO</a></li>
        <li><a href="#the-ppo-objective-function--clipped-surrogate-objective">The PPO Objective Function &ndash; Clipped Surrogate Objective</a></li>
      </ul>
    </li>
  </ul>
</nav>
        
    </div></div>
    



    <div class="content-margin">



<article class="line-numbers">
    
    

    
    
        
        
        
    
        
        
            
            
            
        
        <section id="hfrl-unit-1">


<h2 class="header-anchor-wrapper"><a href="https://huggingface.co/learn/deep-rl-course/en/unit1">HFRL Unit-1</a>
  <a href="#hfrl-unit-1" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h2>

</section>
    
        
        
            
            
            
        
        <section id="summary">


<h3 class="header-anchor-wrapper">Summary
  <a href="#summary" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h3>

<ul>
<li>
<p>Reinforcement Learning is a method where an agent learns by interacting with its environment, using trial and error and feedback from rewards.</p>
</li>
<li>
<p>The goal of an RL agent is to maximize its expected cumulative reward, based on the idea that all goals can be framed as maximizing this reward.</p>
</li>
<li>
<p>The RL process is a loop that outputs a sequence of state, action, reward, and next state.</p>
</li>
<li>
<p>Expected cumulative reward is calculated by discounting future rewards, giving more weight to immediate rewards since they are more predictable than long-term ones.</p>
</li>
<li>
<p>To solve an RL problem, we find an optimal policy, the AI&rsquo;s &ldquo;brain&rdquo; that decides the best action for each state to maximize expected return.</p>
</li>
</ul>
</section>
    
        
        
            
            
            
        
        <section id="two-ways-to-find-optimal-policy">


<h3 class="header-anchor-wrapper">Two ways to find Optimal Policy
  <a href="#two-ways-to-find-optimal-policy" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h3>

<ol>
<li><strong>Policy-based</strong> methods directly optimize the policy by adjusting its parameters to maximize expected return.</li>
<li><strong>Value-based</strong> methods train a value function that estimates the expected return for each state and use it to define the policy.</li>
</ol>
<p>Deep RL is &ldquo;Deep&rdquo; because it uses deep neural networks to estimate the action to take (policy-based) or to estimate the value of a state (value-based).</p>
</section>
    
        
        
            
            
            
        
        <section id="hfrl-unit-2">


<h2 class="header-anchor-wrapper"><a href="https://huggingface.co/learn/deep-rl-course/en/unit2">HFRL Unit-2</a>
  <a href="#hfrl-unit-2" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h2>

</section>
    
        
        
            
            
            
        
        <section id="value-based-methods">


<h3 class="header-anchor-wrapper">Value-based methods
  <a href="#value-based-methods" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h3>

<ul>
<li>
<p>Value-based methods estimate the value of each state (or state-action pair) and derive the policy from these values.</p>
</li>
<li>
<p>We learn a value function that maps a state to the expected value of being at that state.
<img src="/blogs/tutorials/huggingfaceRL/vbm-1.jpg" alt="Value Function"></p>
</li>
<li>
<p>The value of a state is the expected discounted return obtained by following the policy from that state.</p>
</li>
</ul>
</section>
    
        
        
            
            
            
        
        <section id="what-does-it-mean-to-follow-a-policy">


<h4 class="header-anchor-wrapper">What does it mean to &ldquo;follow a policy&rdquo;?
  <a href="#what-does-it-mean-to-follow-a-policy" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h4>

<ul>
<li>The goal of an RL agent is to have an optimal policy $\pi^*$ that maximizes the expected return from any state.
<ul>
<li>Policy-based methods $\rightarrow$ directly train the policy to select what action to take given a state $\rightarrow \pi(a|s) \rightarrow$ We do not need to learn a value function.
<ul>
<li>Policy takes the current state as input and outputs an action or a distribution over possible actions.</li>
<li>We don&rsquo;t define the policy explicitly; instead, we learn it through interactions with the environment.
<img src="/blogs/tutorials/huggingfaceRL/two-approaches-2.jpg" alt="Policy-based"></li>
</ul>
</li>
<li>Value-based methods $\rightarrow$ trains the policy indirectly by learning a value function $\rightarrow V(s) \rightarrow$ We do not need to learn the policy explicitly.
<ul>
<li>The value function takes the current state as input and outputs the expected return (value) of that state.</li>
<li>The policy is not trained or learned directly $\rightarrow$ it is derived from the value function given specific rules.</li>
<li>For example, a common rule is to select the action that leads to the state with the highest value (greedy policy).
<img src="/blogs/tutorials/huggingfaceRL/two-approaches-3.jpg" alt="Value-based"></li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
    
        
        
            
            
            
        
        <section id="the-difference-between-value-based-and-policy-based-methods">


<h4 class="header-anchor-wrapper">The Difference between Value-based and Policy-based methods
  <a href="#the-difference-between-value-based-and-policy-based-methods" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h4>

<ul>
<li>In policy-based methods, the policy is learned directly by training a neural network to output actions based on states.
<ul>
<li>Optimal policy $\pi^*$ is learned directly.</li>
</ul>
</li>
<li>In value-based methods, the policy is derived from a learned value function, which estimates the expected return of states.
<ul>
<li>Optimal policy $ \pi^* $ is derived from the optimal value function $ V^* $$(s)$ or the action-value function $ Q^*(s, a) $.
<img src="/blogs/tutorials/huggingfaceRL/link-value-policy.jpg" alt="Link"></li>
</ul>
</li>
</ul>
</section>
    
        
        
            
            
            
        
        <section id="two-types-of-value-functions">


<h4 class="header-anchor-wrapper">Two types of Value Functions
  <a href="#two-types-of-value-functions" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h4>

<ol>
<li><strong>State-Value Function</strong> $V_\pi(s)$: Estimates the expected return starting from state $s$ and following policy $\pi$.
<ul>
<li>It gives the value of being in a particular state.</li>
<li>Formula:
$$V_\pi(s) = \mathbb{E}_\pi [G_t | S_t = s]$$</li>
<li>Where $G_t$ is the return (cumulative discounted reward) from time step $t$.
<img src="/blogs/tutorials/huggingfaceRL/state-value-function-1.jpg" alt="State-Value Function"></li>
</ul>
</li>
<li><strong>Action-Value Function</strong> $Q_\pi(s, a)$: Estimates the expected return starting from state $s$, taking action $a$, and following policy $\pi$ thereafter.
<ul>
<li>It gives the value of taking a particular action in a particular state.</li>
<li>Formula:
$$Q_\pi(s, a) = \mathbb{E}_\pi [G_t | S_t = s, A_t = a]$$
<img src="/blogs/tutorials/huggingfaceRL/action-state-value-function-1.jpg" alt="Action-Value Function"></li>
</ul>
</li>
</ol>
<p><strong>Difference</strong>: The state-value function evaluates the value of being in a state, while the action-value function evaluates the value of taking a specific action in a state.</p>
<p><strong>Both</strong> case are used to derive the optimal policy $\pi^*$ by selecting actions that maximize the expected return.</p>
<p><strong>Problem</strong>: To calculate the value of a state or state-action pair, we need to know the expected return $G_t$, which depends on future rewards and the policy $\pi$. This can be computationally expensive and complex, especially in environments with many states and actions. Bellman equations provide a recursive way to compute these values efficiently.</p>
</section>
    
        
        
            
            
            
        
        <section id="bellman-equations">


<h3 class="header-anchor-wrapper">Bellman Equations
  <a href="#bellman-equations" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h3>

<ul>
<li>
<p>Simplifies the computation of value functions ($V_\pi(s)$ and $Q_\pi(s, a)$) by breaking them down into immediate rewards and the value of subsequent states.</p>
</li>
<li>
<p>Instead of calculating the expected return for each state or each state-action pair, we can use the Bellman equation.</p>
</li>
<li>
<p>The Bellman equation expresses a stateâ€™s value recursively as the immediate reward plus the discounted value of the next state:
</p>
$$V(S_t) = R_{t+1} + \gamma V(S_{t+1})$$<p>
<img src="/blogs/tutorials/huggingfaceRL/bellman4.jpg" alt="Bellman Equation"></p>
</li>
<li>
<p>In summary, the Bellman equation simplifies value estimation by expressing it as the immediate reward plus the discounted value of the next state.</p>
</li>
<li>
<p>Monte Carlo methods and Temporal Difference (TD) learning are two primary approaches to estimate value functions in reinforcement learning.</p>
</li>
</ul>
</section>
    
        
        
            
            
            
        
        <section id="monte-carlo-methods">


<h3 class="header-anchor-wrapper">Monte Carlo Methods
  <a href="#monte-carlo-methods" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h3>

<ul>
<li>Monte Carlo waits until the end of an episode to calculate the total return ($G_t$) and then updates the value function ($V_\pi(s)$ or $Q_\pi(s, a)$) based on this return.</li>
<li>It requires complete episodes.
<img src="/blogs/tutorials/huggingfaceRL/monte-carlo-approach.jpg" alt="Monte Carlo Methods"></li>
<li>The update rule for the state-value function is:
$$V(S_t) \leftarrow V(S_t) + \alpha [G_t - V(S_t)]$$</li>
<li>Where $\alpha$ is the learning rate, and $G_t$ is the total return from time step $t$.</li>
<li>Then restart the episode and repeat.
<img src="/blogs/tutorials/huggingfaceRL/MC-3p.jpg" alt="Monte Carlo Update"></li>
</ul>
<p><strong>Example of Monte Carlo:</strong></p>
<ul>
<li>We initialize the value function $V(s)$ arbitrarily (e.g., all zeros) for all states $s$.</li>
<li>Our learning rate $\alpha$ is set to 0.1 and discount factor $\gamma$ is 1 (for simplicity).</li>
<li>We run an episode in the environment, collecting states, actions, and rewards until the episode ends.</li>
<li>At the end of the episode, we calculate the return $G_t$ for each time step $t$.</li>
<li>We update the value function for each state visited during the episode using the update rule.</li>
<li>We repeat this process for many episodes, gradually improving our value function estimates.</li>
</ul>
</section>
    
        
        
            
            
            
        
        <section id="temporal-difference-td-learning">


<h3 class="header-anchor-wrapper">Temporal Difference (TD) Learning
  <a href="#temporal-difference-td-learning" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h3>

<ul>
<li>TD learning updates the value function ($V_\pi(s)$ or $Q_\pi(s, a)$) at each time step using the immediate reward and the estimated value of the next state.</li>
<li>It does not require complete episodes and can learn from incomplete sequences.</li>
<li>Because we didn&rsquo;t wait until the end of the episode, we don&rsquo;t have the full return $G_t$.
<ul>
<li>Instead, we use the immediate reward $R_{t+1}$ and the estimated value of the next state $V(S_{t+1})$ to update our value function.</li>
<li>This is called bootstrapping because we are using our current estimate to improve itself incrementally.
<img src="/blogs/tutorials/huggingfaceRL/TD-1.jpg" alt="TD Learning"></li>
</ul>
</li>
<li>The update rule for the state-value function is:
$$V(S_t) \leftarrow V(S_t) + \alpha [R_{t+1} + \gamma V(S_{t+1}) - V(S_t)]$$</li>
<li>Where $\alpha$ is the learning rate, $R_{t+1}$ is the immediate reward, and $V(S_{t+1})$ is the estimated value of the next state.</li>
<li>Then move to the next state and repeat.</li>
<li>This method is known as <strong>TD(0)</strong> because it updates the value function based on a one-step lookahead.</li>
<li>The estimated return is known as the TD target:
$$\text{TD Target} = R_{t+1} + \gamma V(S_{t+1})$$</li>
</ul>
<p><img src="/blogs/tutorials/huggingfaceRL/TD-1p.jpg" alt="TD(0) Update"></p>
</section>
    
        
        
            
            
            
        
        <section id="summary-of-monte-carlo-vs-td-learning">


<h4 class="header-anchor-wrapper">Summary of Monte Carlo vs TD Learning
  <a href="#summary-of-monte-carlo-vs-td-learning" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h4>

<table class="mc-table">
  <thead>
      <tr>
          <th>Aspect</th>
          <th>Monte Carlo Methods</th>
          <th>Temporal Difference (TD) Learning</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Update Timing</td>
          <td>Updates value function at the end of an episode</td>
          <td>Updates value function at each time step</td>
      </tr>
      <tr>
          <td>Requirement</td>
          <td>Requires complete episodes</td>
          <td>Can learn from incomplete sequences</td>
      </tr>
      <tr>
          <td>Return Calculation</td>
          <td>Uses total return $G_t$</td>
          <td>Uses immediate reward and estimated next state value</td>
      </tr>
      <tr>
          <td>Bootstrapping</td>
          <td>No</td>
          <td>Yes</td>
      </tr>
  </tbody>
</table>
</section>
    
        
        
            
            
            
        
        <section id="on-policy-vs-off-policy-learning">


<h3 class="header-anchor-wrapper">On-policy vs Off-policy Learning
  <a href="#on-policy-vs-off-policy-learning" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h3>

<ul>
<li><strong>On-policy</strong> methods learn the value of the policy being executed (the same policy used to make decisions).
<ul>
<li>Example: SARSA (State-Action-Reward-State-Action)</li>
</ul>
</li>
<li><strong>Off-policy</strong> methods learn the value of a different policy than the one being executed (the behavior policy).
<ul>
<li>Example: Q-learning</li>
</ul>
</li>
</ul>
</section>
    
        
        
            
            
            
        
        <section id="q-learning">


<h3 class="header-anchor-wrapper">Q-learning
  <a href="#q-learning" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h3>

<ul>
<li>
<p>Q-Learning is an off-policy value-based method that uses a TD approach to train its action-value function $Q(s, a)$.</p>
</li>
<li>
<p>Approximate the optimal action-value function $Q^*(s, a)$, which gives the maximum expected return for taking action $a$ in state $s$ and following the optimal policy thereafter.
<img src="/blogs/tutorials/huggingfaceRL/Q-function.jpg" alt="Q-Learning"></p>
</li>
<li>
<p>The value of a state, or a state-action pair is the expected cumulative reward our agent gets if it starts at this state (or state-action pair) and then acts accordingly to its policy.</p>
</li>
<li>
<p>The reward is the feedback the agent gets from the environment after taking an action.</p>
</li>
<li>
<p>Q-function is encoded in a table called Q-table:</p>
<table class="mc-table">
  <thead>
      <tr>
          <th>State</th>
          <th>Action 1</th>
          <th>Action 2</th>
          <th>Action 3</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>S1</td>
          <td>Q(S1,A1)</td>
          <td>Q(S1,A2)</td>
          <td>Q(S1,A3)</td>
      </tr>
      <tr>
          <td>S2</td>
          <td>Q(S2,A1)</td>
          <td>Q(S2,A2)</td>
          <td>Q(S2,A3)</td>
      </tr>
      <tr>
          <td>S3</td>
          <td>Q(S3,A1)</td>
          <td>Q(S3,A2)</td>
          <td>Q(S3,A3)</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p>The agent selects actions based on the Q-values in the table, typically choosing the action with the highest Q-value for the current state (greedy policy).</p>
</li>
<li>
<p>The Q-values are updated using the Q-learning update rule:
</p>
$$Q(S_t, A_t) \leftarrow Q(S_t, A_t) + \alpha [R_{t+1} + \gamma \max_a Q(S_{t+1}, a) - Q(S_t, A_t)]$$</li>
<li>
<p>Where $\alpha$ is the learning rate, $R_{t+1}$ is the immediate reward, $\gamma$ is the discount factor, and $\max_a Q(S_{t+1}, a)$ is the maximum estimated Q-value for the next state $S_{t+1}$ over all possible actions $a$.</p>
</li>
<li>
<p>The term $R_{t+1} + \gamma \max_a Q(S_{t+1}, a)$ is known as the TD target in Q-learning.</p>
</li>
<li>
<p>The agent updates the Q-value for the current state-action pair based on the immediate reward and the maximum estimated Q-value for the next state.</p>
</li>
<li>
<p>This update is done at each time step, allowing the agent to learn from each interaction with the environment.</p>
</li>
<li>
<p>Q-function returns the expected cumulative reward for taking action $a$ in state $s$ and following the optimal policy thereafter.</p>
</li>
</ul>
</section>
    
        
        
            
            
            
        
        <section id="summary-of-q-learning">


<h4 class="header-anchor-wrapper">Summary of Q-learning
  <a href="#summary-of-q-learning" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h4>

<ul>
<li>Trains Q-function $Q(s, a)$ $\rightarrow$ action-value function $\rightarrow$ internally uses Q-table that maps state-action pairs to values.</li>
<li>Given a state and an action, Q-function returns the expected cumulative reward for taking that action in that state and following the optimal policy thereafter.</li>
<li>After training, the optimal policy $\pi^*$ can be derived by selecting the action with the highest Q-value for each state:
$$\pi^*(s) = \arg\max_a Q^*(s, a)$$</li>
<li>Q-learning is an off-policy method because it learns the optimal policy independently of the</li>
</ul>
</section>
    
        
        
            
            
            
        
        <section id="q-learning-algorithm">


<h3 class="header-anchor-wrapper">Q-learning Algorithm
  <a href="#q-learning-algorithm" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h3>

<p><img src="/blogs/tutorials/huggingfaceRL/Q-learning-2.jpg" alt="Q-learning Algorithm"></p>
<ul>
<li>Step 1: Initialize the Q-table with arbitrary values (e.g., all zeros) for all state-action pairs.</li>
<li>Step 2: Choose an action using the epsilon-greedy strategy
<img src="/blogs/tutorials/huggingfaceRL/Q-learning-4.jpg" alt="Epsilon-Greedy Strategy">
<ul>
<li>With probability $\epsilon$, select a random action (exploration).</li>
<li>With probability $1 - \epsilon$, select the action with the highest Q-value for the current state (exploitation).</li>
<li>As training progresses, $\epsilon$ is typically decayed to reduce exploration and increase exploitation.
<img src="/blogs/tutorials/huggingfaceRL/Q-learning-5.jpg" alt="Epsilon Decay"></li>
</ul>
</li>
<li>Step 3: Take the action, observe the reward and the next state, $A_t, R_{t+1}, S_{t+1}$.</li>
<li>Step 4: Update the Q-value for the current state-action pair using the Q-learning update rule.
<ul>
<li>Use the update formula to adjust the Q-value based on the observed reward and the maximum estimated Q-value for the next state.</li>
<li>To produce the TD target, we use the immediate reward $R_{t+1}$ and the maximum estimated discounted Q-value for the next state $S_{t+1}$ over all possible actions. This is called bootstrapping because we are using our current estimate to improve itself incrementally.
<img src="/blogs/tutorials/huggingfaceRL/Q-learning-7.jpg" alt="Bootstrapping">
<img src="/blogs/tutorials/huggingfaceRL/Q-learning-8.jpg" alt="Bootstrapping-2"></li>
<li>To get the TD target, we use:
<ul>
<li>We obtain the reward $R_{t+1}$ from the environment after taking action $A_t$ in state $S_t$.</li>
<li>To get the best state-action pair value for the next state $S_{t+1}$, we look at all possible actions $a$ in that state and select the one with the highest Q-value: $\max_a Q(S_{t+1}, a)$ $\rightarrow$ Note that this is not $\epsilon$-greedy; this is always taking the maximum value.</li>
<li>We multiply this maximum Q-value by the discount factor $\gamma$ to account for the time value of future rewards.</li>
<li>Finally, we add the immediate reward $R_{t+1}$ to the discounted maximum Q-value to get the TD target:
$$\text{TD Target} = R_{t+1} + \gamma \max_a Q(S_{t+1}, a)$$</li>
<li>Then when the update of this Q-value is done, we start in a new state and select another action using the $\epsilon$-greedy strategy.</li>
<li>This is why Q-learning is considered an <strong>off-policy method</strong> because the action used to update the Q-value (the one that maximizes the Q-value for the next state) is not necessarily the action that was actually taken (which could have been a random action due to exploration).</li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
    
        
        
            
            
            
        
        <section id="off-policy-vs-on-policy">


<h3 class="header-anchor-wrapper">Off-policy vs On-policy
  <a href="#off-policy-vs-on-policy" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h3>

<ul>
<li>Off-policy: using a different policy for acting (inference) and learning (training).
<ul>
<li>Example: Q-learning $\rightarrow$ uses $\epsilon$-greedy for acting and greedy (max) for learning.</li>
</ul>
</li>
<li>On-policy: using the same policy for acting and learning.
<ul>
<li>Example: SARSA $\rightarrow$ uses $\epsilon$-greedy for both acting and learning.</li>
</ul>
</li>
</ul>
<p><img src="/blogs/tutorials/huggingfaceRL/off-on-4.jpg" alt="Off-policy vs On-policy"></p>
</section>
    
        
        
            
            
            
        
        <section id="hfrl-unit-3">


<h2 class="header-anchor-wrapper"><a href="https://huggingface.co/learn/deep-rl-course/en/unit3">HFRL Unit-3</a>
  <a href="#hfrl-unit-3" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h2>

<ul>
<li>Producing and updating the Q-table becomes challenging in environments with large or continuous state and action spaces.</li>
<li>Deep Q-Networks (DQN) address this by using neural networks to approximate the Q-function instead of a table.</li>
<li>DQN uses a neural network to take the state as input and output Q-values for all possible actions.</li>
</ul>
<p><img src="/blogs/tutorials/huggingfaceRL/deep.jpg" alt="DQN-basic"></p>
<p><img src="/blogs/tutorials/huggingfaceRL/deep-q-network.jpg" alt="DQN-architecture"></p>
</section>
    
        
        
            
            
            
        
        <section id="q-function-recap">


<h3 class="header-anchor-wrapper">Q-Function Recap
  <a href="#q-function-recap" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h3>

<ul>
<li>The Q-function $Q(s, a)$ is an action-value function that determines the value of being at a particular state and taking a specific action at that state.</li>
<li>Q-Learning is the algorithm that trains the Q-function.</li>
<li>&ldquo;Q&rdquo; stands for &ldquo;quality,&rdquo; representing the quality of a state-action pair in terms of expected cumulative reward.</li>
<li>Internally Q-function is represented as a Q-table, which maps state-action pairs to their corresponding Q-values.</li>
<li>Issue: In environments with large or continuous state and action spaces, maintaining and updating a Q-table becomes impractical $\rightarrow$ Qtable doesn&rsquo;t scale well.</li>
</ul>
</section>
    
        
        
            
            
            
        
        <section id="deep-q-networks-dqn">


<h3 class="header-anchor-wrapper">Deep Q-Networks (DQN)
  <a href="#deep-q-networks-dqn" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h3>

<ul>
<li>DQN uses a neural network to approximate the Q-function, allowing it to handle large or continuous state spaces.</li>
<li>The neural network takes the state as input and outputs Q-values for all possible actions.</li>
<li>The architecture of a DQN typically includes:
<ul>
<li>Input Layer: Receives the state representation (e.g., raw pixels for images).</li>
<li>Hidden Layers: Multiple fully connected layers with activation functions (e.g., ReLU)</li>
<li>Output Layer: Outputs Q-values for each possible action.</li>
</ul>
</li>
<li>The DQN is trained using the Q-learning update rule, but instead of updating a Q-table, we update the weights of the neural network.</li>
<li>The loss function used for training is based on the difference between the predicted Q-values and the target Q-values (TD target).</li>
<li>The target Q-values are computed using the immediate reward and the maximum estimated Q-value for the next state, similar to Q-learning</li>
</ul>
</section>
    
        
        
            
            
            
        
        <section id="preprocessing-the-input-and-temporal-limits">


<h3 class="header-anchor-wrapper">Preprocessing the Input and Temporal Limits
  <a href="#preprocessing-the-input-and-temporal-limits" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h3>

<p><img src="/blogs/tutorials/huggingfaceRL/preprocessing.jpg" alt="Preprocessing"></p>
<ul>
<li>In environments with high-dimensional inputs (e.g., images), preprocessing is essential to reduce complexity and improve learning efficiency.</li>
<li>Common preprocessing steps include:
<ul>
<li>Grayscaling: Convert RGB images to grayscale to reduce the number of input channels.</li>
<li>Resizing: Resize images to a smaller, fixed size (e.g., 84x84 pixels), cropping unnecessary parts to focus on relevant information.</li>
<li>Normalization: Scale pixel values to a range (e.g., [0, 1] or [-1, 1]) to improve training stability.</li>
<li>Frame Stacking: Stack multiple consecutive frames to provide temporal context, allowing the agent to infer motion and dynamics.</li>
</ul>
</li>
<li>Temporal limits are imposed on episodes to prevent them from running indefinitely, ensuring that the agent learns to complete tasks within a reasonable time frame.
<img src="/blogs/tutorials/huggingfaceRL/temporal-limitation-2.jpg" alt="Temporal Limits"></li>
</ul>
</section>
    
        
        
            
            
            
        
        <section id="the-deep-q-learning-algorithm">


<h3 class="header-anchor-wrapper">The Deep Q-Learning Algorithm
  <a href="#the-deep-q-learning-algorithm" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h3>

<ul>
<li>
<p>We create a loss function that compares our current Q-value estimates with the Q-target and uses gradient descent to update the Deep Q-Network&rsquo;s weights to approximate the Q-values better.
<img src="/blogs/tutorials/huggingfaceRL/Q-target.jpg" alt="Q-target"></p>
</li>
<li>
<p>The Deep Q-Learning algorithm has two phases: the interaction phase and the training phase.</p>
</li>
<li>
<p><strong>Interaction or Sampling Phase</strong>:</p>
<ul>
<li>The agent performs actions and stores the observed experience tuples in a replay memory.</li>
<li>Experience tuples typically include the current state, action taken, reward received, and next state.</li>
<li>This phase allows the agent to explore the environment and gather diverse experiences for training.</li>
</ul>
</li>
<li>
<p><strong>Training Phase</strong>:</p>
<ul>
<li>The agent samples mini-batches of experience tuples from the replay memory to train the Deep Q-Network.</li>
<li>The loss function is computed based on the difference between the predicted Q-values and the target Q-values (TD target).</li>
<li>The network&rsquo;s weights are updated using gradient descent to minimize the loss.</li>
<li>This phase allows the agent to learn from past experiences and improve its policy over time.</li>
</ul>
</li>
</ul>
<p><img src="/blogs/tutorials/huggingfaceRL/sampling-training.jpg" alt="DQN Algorithm"></p>
<ul>
<li>DQN can suffer from instability because of combining a non-linear function approximator (neural network) and bootstrapping (using current estimates to update themselves).</li>
<li>To address this, DQN uses 3 key techniques:
<ol>
<li>Experience Replay to make more efficient use of experiences.</li>
<li>Fixed Q-Target to stabilize the training.</li>
<li>Double Deep Q-Learning, to handle the problem of the overestimation of Q-values.</li>
</ol>
</li>
</ul>
</section>
    
        
        
            
            
            
        
        <section id="experience-replay">


<h4 class="header-anchor-wrapper">Experience Replay
  <a href="#experience-replay" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h4>

<ul>
<li>Experience Replay stores the agent&rsquo;s experiences in a replay memory (buffer) and samples mini-batches from this memory to train the network.</li>
<li>This has two functions:
<ol>
<li>Make more efficient use of the experiences during the training. Usually, in online reinforcement learning, the agent interacts with the environment, gets experiences (state, action, reward, and next state), learns from them (updates the neural network), and discards them. This is not efficient. By storing experiences in a replay memory, we can reuse them multiple times for training, <strong>improving sample efficiency</strong>.</li>
<li>Avoid forgetting previous experiences (aka catastrophic interference, or catastrophic forgetting) and reduce the correlation between experiences. Catastrophic forgetting happens when the agent learns new information and forgets previously learned information. By sampling randomly from a replay memory, we ensure that the training data is more diverse and less correlated, which helps stabilize learning.</li>
</ol>
</li>
</ul>
</section>
    
        
        
            
            
            
        
        <section id="fixed-q-target">


<h4 class="header-anchor-wrapper">Fixed Q-Target
  <a href="#fixed-q-target" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h4>

<ul>
<li>We do not know the real TD target because we do not know the optimal Q-values for the next state.</li>
<li>Bellman equation tells us that the optimal Q-value for the next state is the maximum Q-value over all possible actions in that state.</li>
<li>Problem: We are using the same parameters (weights) of the neural network to estimate both the current Q-values and the target Q-values. So, there&rsquo;s significant correlation between the two, which can lead to instability and divergence during training.</li>
<li>Solution: Use a separate neural network, called the target network, to compute the target Q-values.
<ul>
<li>The target network has the same architecture as the main network but with different weights.</li>
<li>The weights of the target network are updated less frequently (e.g., every few thousand steps) by copying the weights from the main network.</li>
<li>This decouples the target Q-value estimation from the current Q-value estimation, reducing correlation and improving stability.</li>
</ul>
</li>
<li>The target Q-value is computed using the target network:
$$\text{TD Target} = R_{t+1} + \gamma \max_a Q_{\text{target}}(S_{t+1}, a)$$</li>
<li>Where $Q_{\text{target}}$ is the Q-value estimated by the target network.</li>
</ul>
</section>
    
        
        
            
            
            
        
        <section id="double-deep-q-learning">


<h4 class="header-anchor-wrapper">Double Deep Q-Learning
  <a href="#double-deep-q-learning" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h4>

<ul>
<li>This handles the problem of the overestimation of Q-values.</li>
<li>When calculating the target Q-value, we use the main network to select the action that maximizes the Q-value for the next state, but we use the target network to evaluate this action. How are we sure that the best action for the next state is the one that maximizes the Q-value according to the main network? It might be an overestimation.</li>
<li>The accuracy of the Q-values depends on what action we have tried and what states we have explored.</li>
<li>If non-optimal actions are regularly given a higher Q value than the optimal best action, the learning will be complicated.</li>
<li>The solution is to use the Double Q-learning approach:
<ul>
<li>Use the DQN network to select the best action that maximizes the Q-value for the next state.</li>
<li>Use the target network to evaluate this action and compute the target Q-value.</li>
</ul>
</li>
<li>This reduces the overestimation bias because the action selection and evaluation are decoupled.</li>
<li>The target Q-value in Double DQN is computed as:
$$\text{TD Target} = R_{t+1} + \gamma Q_{\text{target}}(S_{t+1}, \arg\max_a Q_{\text{main}}(S_{t+1}, a))$$</li>
<li>Where $Q_{\text{main}}$ is the Q-value estimated by the main network, and $Q_{\text{target}}$ is the Q-value estimated by the target network.</li>
</ul>
</section>
    
        
        
            
            
            
        
        <section id="summary-of-dqn-improvements">


<h4 class="header-anchor-wrapper">Summary of DQN Improvements
  <a href="#summary-of-dqn-improvements" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h4>

<table class="mc-table">
  <thead>
      <tr>
          <th>Technique</th>
          <th>Purpose</th>
          <th>Benefit</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Experience Replay</td>
          <td>Store and reuse experiences</td>
          <td>Improves sample efficiency and reduces correlation between experiences</td>
      </tr>
      <tr>
          <td>Fixed Q-Target</td>
          <td>Use a separate target network for Q-value estimation</td>
          <td>Stabilizes training by reducing correlation between current and target Q-values</td>
      </tr>
      <tr>
          <td>Double DQN</td>
          <td>Decouple action selection and evaluation</td>
          <td>Reduces overestimation bias in Q-value estimates</td>
      </tr>
  </tbody>
</table>
</section>
    
        
        
            
            
            
        
        <section id="hfrl-unit-4">


<h2 class="header-anchor-wrapper"><a href="https://huggingface.co/learn/deep-rl-course/en/unit4">HFRL Unit-4</a>
  <a href="#hfrl-unit-4" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h2>

</section>
    
        
        
            
            
            
        
        <section id="policy-based-methods">


<h3 class="header-anchor-wrapper">Policy-based Methods
  <a href="#policy-based-methods" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h3>

<ul>
<li>
<p>RL: find optimal policy $\pi^*$ that maximizes expected return.</p>
</li>
<li>
<p>Reward Hypothesis: all goals can be framed as maximizing expected cumulative reward.</p>
</li>
<li>
<p>Two main approaches to find optimal policy:</p>
<ol>
<li>Policy-based methods: directly optimize the policy $\pi(a|s)$.</li>
<li>Value-based methods: learn a value function $V(s)$ or $Q(s, a)$ and derive the policy from it.</li>
</ol>
<ul>
<li>Actor-Critic methods: combine both approaches by learning a policy and a value function simultaneously.</li>
</ul>
</li>
<li>
<p>In policy based methods we directly learn to approximate the optimal policy $\pi^*$ by adjusting the parameters of the policy to maximize the expected return.</p>
<ul>
<li>
<p>The idea is to parameterize the policy using a neural network, $\pi_\theta$, which will output a probability distribution over actions given a state.
<img src="/blogs/tutorials/huggingfaceRL/stochastic_policy.png" alt="Stochastic Policy"></p>
</li>
<li>
<p>We use gradient ascent to update the policy parameters $\theta$ in the direction that increases the expected return.</p>
</li>
<li>
<p>We control the parameter $\theta$ to make the policy better and better over time.
<img src="/blogs/tutorials/huggingfaceRL/policy_based.png" alt="Policy Based Methods"></p>
</li>
<li>
<p>We can directly optimize our policy $\pi_\theta$ to output a probability distribution over actions $\pi_\theta(a|s)$ that maximizes the expected return.</p>
</li>
<li>
<p>We define the objective function $J(\theta)$ as the expected return when following the policy $\pi_\theta$:
</p>
$$J(\theta) = \mathbb{E}_{\pi_\theta}[G_t]$$</li>
<li>
<p>Where $G_t$ is the return (cumulative discounted reward) from time step $t$.</p>
</li>
<li>
<p>The goal is to find the optimal parameters $\theta^*$ that maximize $J(\theta)$:
</p>
$$\theta^* = \arg\max_\theta J(\theta)$$</li>
<li>
<p>We use gradient ascent to update the policy parameters $\theta$:
</p>
$$\theta \leftarrow \theta + \alpha \nabla_\theta J(\theta)$$</li>
<li>
<p>Where $\alpha$ is the learning rate, and $\nabla_\theta J(\theta)$ is the gradient of the objective function with respect to the policy parameters $\theta$.</p>
</li>
</ul>
</li>
</ul>
</section>
    
        
        
            
            
            
        
        <section id="the-difference-between-policy-based-and-policy-gradient-methods">


<h3 class="header-anchor-wrapper">The difference between Policy-based and policy-gradient methods
  <a href="#the-difference-between-policy-based-and-policy-gradient-methods" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h3>

<ul>
<li>Policy-based methods refer to a broader category of RL algorithms that directly optimize the policy $\pi(a|s)$ to maximize the expected return.</li>
<li>Policy-gradient methods are a specific type of policy-based methods that use gradient ascent to update the policy parameters $\theta$ based on the gradient of the objective function $J(\theta)$.</li>
<li>In summary, all policy-gradient methods are policy-based methods, but not all policy-based methods are policy-gradient methods.</li>
</ul>
<p><strong>Why use policy-based methods?</strong></p>
<ul>
<li>The simplicity of integration $\rightarrow$ directly optimize the policy without needing to learn a value function.</li>
<li>Learn stochastic policies $\rightarrow$ can learn policies that output a probability distribution over actions, allowing for exploration and handling uncertainty.</li>
<li>No perceptual aliasing $\rightarrow$ Perceptual aliasing is when two states seem (or are) the same but need different actions.
<ul>
<li>Value-based methods can struggle with this because they rely on the value function, which may not distinguish between these states as they are quasi-greedy in nature.</li>
<li>Policy-based methods can learn different actions for these states directly through the policy.</li>
</ul>
</li>
<li>More efficient in high-dimensional or continuous action spaces $\rightarrow$ Value-based methods can struggle with large or continuous action spaces because they need to estimate the value for each state-action pair.
<ul>
<li>Policy-based methods can directly output actions without needing to evaluate all possible actions.</li>
</ul>
</li>
<li>Better convergence properties $\rightarrow$ Policy-based methods can have better convergence properties in some scenarios, especially when the policy is stochastic.
<ul>
<li>Stochastic policy action preferences change smoothly, leading to more stable learning.</li>
</ul>
</li>
</ul>
<p><strong>Disadvantages of Policy-based methods</strong></p>
<ul>
<li>Convergence to local optima $\rightarrow$ Policy-gradient methods can converge to local optima, especially in complex environments with many suboptimal policies.</li>
<li>High variance in gradient estimates $\rightarrow$ The gradient estimates used in policy-gradient methods can have high variance, leading to unstable learning.</li>
<li>Slower learning $\rightarrow$ Policy-based methods can be slower to learn compared to value-based methods, especially in environments with sparse rewards.</li>
</ul>
</section>
    
        
        
            
            
            
        
        <section id="policy-gradient-methods">


<h3 class="header-anchor-wrapper">Policy Gradient Methods
  <a href="#policy-gradient-methods" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h3>

<ul>
<li>Find parameters $\theta$ of a policy $\pi_\theta(a|s)$ that maximizes the expected return $J(\theta)$.</li>
<li>Outputs a probability distribution over actions given a state.</li>
<li>The probability of taking action $a$ in state $s$ is given by $\pi_\theta(a|s)$ $\rightarrow$ known as <em>action preference</em>.</li>
</ul>
<p><img src="/blogs/tutorials/huggingfaceRL/policy_based.png" alt="Policy Gradient Illustration"></p>
<p><strong>Goal: Control the probability distribution of actions by tuning the policy so that good actions are more likely to be chosen.</strong></p>
<ul>
<li>Let the agent interact with the environment using its current policy $\pi_\theta$ and collect experiences (state, action, reward, next state).</li>
<li>If the action taken leads to a high reward, we want to increase the probability of taking that action in that state.</li>
<li>For each state-action pair $(s,a)$, we want to increase the probability $\pi_\theta(a|s)$ if the action $a$ taken in state $s$ leads to a high return.</li>
<li>Conversely, if the action taken leads to a low reward, we want to decrease the probability of taking that action in that state.</li>
</ul>
<p><img src="/blogs/tutorials/huggingfaceRL/pg_bigpicture.jpg" alt="Policy Gradient Big Picture"></p>
<ul>
<li>Stochastic policy $\pi_\theta(a|s)$: outputs a probability distribution over actions given a state.</li>
</ul>
<p><img src="/blogs/tutorials/huggingfaceRL/stochastic_policy.png" alt="Stochastic Policy"></p>
<ul>
<li>How to know if our policy is good $\rightarrow$ we need a way to evaluate the quality of our policy.</li>
<li>We define the objective function $J(\theta)$ as the expected return when following the policy $\pi_\theta$.</li>
<li>Measures the performance of the agent given a trajectory $\tau$ (sequence of states, actions) and outputs a scalar value representing the expected return.</li>
</ul>
<p><img src="/blogs/tutorials/huggingfaceRL/objective.jpg" alt="Objective"></p>
<ul>
<li>The expected return (also called expected cumulative reward), is the weighted average (where the weights are given by $P(\tau; \theta)$) of the returns $R(\tau)$ over all possible trajectories $\tau$ that can be generated by following the policy $\pi_\theta$.</li>
<li>$R(\tau)$ is the return (cumulative discounted reward) obtained by following an arbitrary trajectory $\tau$. We need to multiply it by the probability of that trajectory occurring under the current policy, $P(\tau; \theta)$ to get the expected return.</li>
<li>$P(\tau; \theta)$ is the probability of observing a trajectory $\tau$ when following the policy $\pi_\theta$. This probability depends on the policy parameters $\theta$ because the policy determines the actions taken at each state, which in turn affects the trajectory.</li>
<li>$J(\theta)$ is the expected return when following the policy $\pi_\theta$. We calculate it by summing over all possible trajectories $\tau$, multiplying the return $R(\tau)$ for each trajectory by its probability $P(\tau; \theta)$.</li>
<li>The goal of policy-gradient methods is to find the optimal parameters $\theta^*$ that maximize the objective function $J(\theta)$:
$$\theta^* = \arg\max_\theta J(\theta)$$</li>
</ul>
<p><img src="/blogs/tutorials/huggingfaceRL/probability.png" alt="Probability of Trajectory"></p>
<p><img src="/blogs/tutorials/huggingfaceRL/expected_reward.png" alt="Expected Reward"></p>
<p><img src="/blogs/tutorials/huggingfaceRL/max_objective.png" alt="Max Objective"></p>
</section>
    
        
        
            
            
            
        
        <section id="gradient-ascent-and-the-policy-gradient-theorem">


<h4 class="header-anchor-wrapper">Gradient Ascent and the Policy Gradient Theorem
  <a href="#gradient-ascent-and-the-policy-gradient-theorem" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h4>

<ul>
<li>We want to find the optimal parameters $\theta^*$ that maximize the objective function $J(\theta)$.</li>
<li>It&rsquo;s inverse of gradient descent (used in supervised learning) because we want to maximize the objective function instead of minimizing it.</li>
<li>Update step for gradient ascent:
$$\theta \leftarrow \theta + \alpha \times \nabla_\theta J(\theta)$$</li>
<li>Where $\alpha$ is the learning rate, and $\nabla_\theta J(\theta)$ is the gradient of the objective function with respect to the policy parameters.</li>
<li>The gradient $\nabla_\theta J(\theta)$ tells us how to change the policy parameters $\theta$ to increase the expected return $J(\theta)$.</li>
<li>Two problems with computing the gradient $\nabla_\theta J(\theta)$:
<ol>
<li>We cannot calculate the true gradient of the objective function as it requires calculating the probability of each possible trajectory, which is infeasible in complex environments. So we calculate a gradient estimation with a sample-based estimate by collecting a batch of trajectories by interacting with the environment using the current policy $\pi_\theta$.</li>
<li>To differentiate this objective function we have to differentiate the state distribution which is a Markov Decision Process (MDP) and it&rsquo;s dependent of the environment dynamics which we don&rsquo;t know.</li>
</ol>
</li>
<li>To solve these, we use the Policy Gradient Theorem to derive a more practical expression for the gradient that does not depend on the state distribution.</li>
</ul>
<p><img src="/blogs/tutorials/huggingfaceRL/policy_gradient_theorem.png" alt="Policy Gradient Theorem"></p>
</section>
    
        
        
            
            
            
        
        <section id="the-reinforce-algorithm">


<h4 class="header-anchor-wrapper">The REINFORCE Algorithm
  <a href="#the-reinforce-algorithm" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h4>

<ul>
<li>REINFORCE is a Monte Carlo policy-gradient algorithm that uses the policy gradient theorem to estimate the gradient of the objective function.</li>
<li>It collects complete episodes (trajectories) by interacting with the environment using the current policy $\pi_\theta$.</li>
<li>For each time step $t$ in the episode, it computes the return $G_t$ (cumulative discounted reward) from time step $t$ to the end of the episode.</li>
<li>The policy parameters $\theta$ are updated using the following update rule:
$$\theta \leftarrow \theta + \alpha \times G_t \times \nabla_\theta \log \pi_\theta(A_t | S_t)$$</li>
<li>Where $\alpha$ is the learning rate, $G_t$ is the return from time step $t$, and $\nabla_\theta \log \pi_\theta(A_t | S_t)$ is the gradient of the log-probability of the action taken at time step $t$.</li>
<li>The term $G_t \times \nabla_\theta \log \pi_\theta(A_t | S_t)$ is known as the policy gradient estimate.</li>
</ul>
<p><img src="/blogs/tutorials/huggingfaceRL/policy_gradient_one.png" alt="Update from one trajectory"></p>
<p><img src="/blogs/tutorials/huggingfaceRL/policy_gradient_multiple.png" alt="Update from multiple trajectories"></p>
<ul>
<li>The REINFORCE algorithm can be summarized in the following steps:
<ol>
<li>Initialize the policy parameters $\theta$ randomly.</li>
<li>For each episode:
<ul>
<li>Collect a trajectory by interacting with the environment using the current policy $\pi_\theta$.</li>
<li>For each time step $t$ in the episode:
<ul>
<li>Compute the return $G_t$ from time step $t$ to the end of the episode.</li>
<li>Update the policy parameters $\theta$ using the update rule.</li>
</ul>
</li>
</ul>
</li>
<li>Repeat until convergence.</li>
</ol>
</li>
</ul>
</section>
    
        
        
            
            
            
        
        <section id="hfrl-unit-5">


<h2 class="header-anchor-wrapper"><a href="https://huggingface.co/learn/deep-rl-course/en/unit5">HFRL Unit-5</a>
  <a href="#hfrl-unit-5" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h2>

<p>SKIP &ndash; FOR NOW &ndash; NOT NEEDED</p>
</section>
    
        
        
            
            
            
        
        <section id="hfrl-unit-6">


<h2 class="header-anchor-wrapper"><a href="https://huggingface.co/learn/deep-rl-course/en/unit6">HFRL Unit-6</a>
  <a href="#hfrl-unit-6" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h2>

<ul>
<li>REINFORCE has high variance in its gradient estimates, leading to unstable learning.</li>
<li>This high variance arises because we are using Monte Carlo estimates of the return $G_t$, which can vary significantly between episodes.</li>
<li>Policy gradient estimation is the direction of the steepest ascent in the policy parameter space that maximizes the expected return.</li>
<li>In Monte Carlo methods like REINFORCE, we estimate the policy gradient using complete episodes, which can lead to high variance in the estimates. We need a lot of samples (episodes) to get a reliable estimate of the gradient.</li>
<li>Actor-Critic methods combine policy-based and value-based approaches to reduce the variance in policy gradient estimates.</li>
<li>In this approach, we have two components:
<ol>
<li><strong>Actor</strong>: The policy network $\pi_\theta(a|s)$ that outputs a probability distribution over actions given a state.</li>
<li><strong>Critic</strong>: The value network $V_w(s)$ that estimates the value of a state.</li>
</ol>
</li>
<li>Advantage Actor-Critic is an extension of the Actor-Critic method that uses the advantage function to reduce variance further.</li>
</ul>
</section>
    
        
        
            
            
            
        
        <section id="the-problem-of-high-variance-in-reinforce">


<h3 class="header-anchor-wrapper">The Problem of High Variance in REINFORCE
  <a href="#the-problem-of-high-variance-in-reinforce" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h3>

<ul>
<li>
<p>In REINFORCE, we want to increase the probability of actions that lead to high returns and decrease the probability of actions that lead to low returns.
<img src="/blogs/tutorials/huggingfaceRL/pg.jpg" alt="Policy Gradient"></p>
</li>
<li>
<p>The return $R(\tau)$ is calculated using <em>Monte Carlo</em> sampling.</p>
</li>
<li>
<p>We collect a trajectory $\tau$ by interacting with the environment using the current policy $\pi_\theta$.</p>
</li>
<li>
<p>The return $R(\tau)$ is the cumulative discounted reward obtained by following the trajectory $\tau$.</p>
</li>
<li>
<p>If the return is good, all actions will be &ldquo;reinforced&rdquo; by increasing their likelihood of being chosen in the future.</p>
</li>
<li>
<p>This method is unbiased as we are using the true return $R(\tau)$ to update the policy.</p>
</li>
<li>
<p>However, because of stochasticity in the environment and the policy, the return $R(\tau)$ can vary significantly between episodes, leading to high variance in the policy gradient estimates.</p>
</li>
<li>
<p>High variance in the gradient estimates can lead to unstable learning and slow convergence.</p>
</li>
</ul>
<p><img src="/blogs/tutorials/huggingfaceRL/variance.jpg" alt="Variance"></p>
</section>
    
        
        
            
            
            
        
        <section id="advantage-actor-critic-a2c">


<h3 class="header-anchor-wrapper">Advantage Actor-Critic (A2C)
  <a href="#advantage-actor-critic-a2c" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h3>

<ul>
<li>Actor-Critic methods address the high variance problem by introducing a value function (the Critic) to estimate the expected return.</li>
<li>We have two function approximators:
<ol>
<li><strong>Actor</strong>: The policy network $\pi_\theta(a|s)$ that outputs a probability distribution over actions given a state.</li>
<li><strong>Critic</strong>: The value network $V_w(s)$ that estimates how good the action taken in a state is.</li>
</ol>
</li>
</ul>
</section>
    
        
        
            
            
            
        
        <section id="actor-critic-process">


<h4 class="header-anchor-wrapper">Actor Critic Process
  <a href="#actor-critic-process" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h4>

<ul>
<li>Actor: a policy function parameterized by $\theta$: $\pi_\theta(s)$</li>
<li>Critic: a value function parameterized by $w$: $\hat{q}_w(s, a)$</li>
<li>At each timestep $t$, we get the current state $S_t$ from the environment and pass it to the Actor and Critic networks.
<img src="/blogs/tutorials/huggingfaceRL/step1.jpg" alt="Step-1"></li>
<li>Our policy takes the state and outputs an action $A_t$.</li>
<li>The critic takes that action also as an input and using the state $S_t$ along with the action $A_t$ outputs an estimate of the value of taking that action in that state: $\hat{q}_w(S_t, A_t) \rightarrow Q$ estimate.
<img src="/blogs/tutorials/huggingfaceRL/step2.jpg" alt="Step-2"></li>
<li>We take that action $A_t$ and pass it to the environment, which returns the next state $S_{t+1}$ and the reward $R_{t+1}$.
<img src="/blogs/tutorials/huggingfaceRL/step3.jpg" alt="Step-3"></li>
<li>The Actor updates its policy parameters $\theta$ using the Q-value estimate from the Critic.
<img src="/blogs/tutorials/huggingfaceRL/step4.jpg" alt="Step-4"></li>
<li>The Actor produces the next action $A_{t+1}$ based on the next state $S_{t+1}$.
<img src="/blogs/tutorials/huggingfaceRL/step5.jpg" alt="Step-5"></li>
<li>The Critic updates its value function parameters $w$ using the TD error.</li>
</ul>
</section>
    
        
        
            
            
            
        
        <section id="adding-advantage-in-actor-critic">


<h4 class="header-anchor-wrapper">Adding Advantage in Actor-Critic
  <a href="#adding-advantage-in-actor-critic" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h4>

<ul>
<li>Instead of using the Q-value estimate $\hat{q}_w(S_t, A_t)$ directly, we can use the advantage function to reduce variance further.</li>
<li>The advantage function $A(s, a)$ measures how much better taking action $a$ in state $s$ is compared to the average action in that state.</li>
<li>The advantage function is defined as:
$$A(s, a) = Q(s, a) - V(s)$$</li>
<li>Where $Q(s, a)$ is the action-value function, and $V(s)$ is the state-value function.</li>
<li>In Advantage Actor-Critic, we use the advantage function to update the policy parameters $\theta$:
$$\theta \leftarrow \theta + \alpha \times A(S_t, A_t) \times \nabla_\theta \log \pi_\theta(A_t | S_t)$$</li>
<li>Where $A(S_t, A_t)$ is the advantage estimate for the action taken at time step $t$.</li>
<li>The advantage estimate can be computed using the TD error:
$$A(S_t, A_t) = R_{t+1} + \gamma V_w(S_{t+1}) - V_w(S_t)$$</li>
<li>Where $R_{t+1}$ is the immediate reward, $\gamma$ is the discount factor, and $V_w(S_{t+1})$ and $V_w(S_t)$ are the value estimates from the Critic network.</li>
</ul>
<p><img src="/blogs/tutorials/huggingfaceRL/advantage2.jpg" alt="Advantage"></p>
</section>
    
        
        
            
            
            
        
        <section id="hfrl-unit-7">


<h2 class="header-anchor-wrapper"><a href="https://huggingface.co/learn/deep-rl-course/en/unit7">HFRL Unit-7</a>
  <a href="#hfrl-unit-7" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h2>

<ul>
<li>SKIP &ndash; FOR NOW &ndash; NOT NEEDED</li>
</ul>
</section>
    
        
        
            
            
            
        
        <section id="hfrl-unit-8">


<h2 class="header-anchor-wrapper"><a href="https://huggingface.co/learn/deep-rl-course/en/unit8">HFRL Unit-8</a>
  <a href="#hfrl-unit-8" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h2>

<ul>
<li>Proximal Policy Optimization is an architecture that improves the RL agent&rsquo;s training stability by avoiding policy updates that are too large.</li>
<li>To do that we use a ratio that indicates the difference between our current policy and old policy and clip this ratio to a range of $[1 - \epsilon, 1 + \epsilon]$.</li>
</ul>
</section>
    
        
        
            
            
            
        
        <section id="the-intuition-behind-ppo">


<h3 class="header-anchor-wrapper">The Intuition Behind PPO
  <a href="#the-intuition-behind-ppo" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h3>

<ul>
<li>
<p>We want to stablize the training of the policy by avoiding large updates that can lead to instability.</p>
</li>
<li>
<p>Reasons:</p>
<ul>
<li>Smaller updates lead to more stable learning and more likely convergence to a good policy.</li>
<li>Large updates can lead to divergence, falling off the cliff, and unstable learning, leading to poor performance and too long to converge.</li>
</ul>
</li>
<li>
<p>To update policy conservatively, we measure how much the current policy changed compared to the former one using a ratio calculation between the current policy and the old policy.</p>
</li>
<li>
<p>We clip this ratio to a range of $[1 - \epsilon, 1 + \epsilon]$ to limit the change in the policy.</p>
</li>
<li>
<p>This is why it&rsquo;s called Proximal Policy Optimization $\rightarrow$ we are optimizing the policy while keeping it close to the old policy (proximal).</p>
</li>
</ul>
</section>
    
        
        
            
            
            
        
        <section id="the-ppo-objective-function--clipped-surrogate-objective">


<h3 class="header-anchor-wrapper">The PPO Objective Function &ndash; Clipped Surrogate Objective
  <a href="#the-ppo-objective-function--clipped-surrogate-objective" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h3>

<p><img src="/blogs/tutorials/huggingfaceRL/lpg.jpg" alt="Policy Objective"></p>
<ul>
<li>The objective function for PPO is called the clipped surrogate objective.</li>
<li>This constrain the policy change in small range using a clipping mechanism.
<img src="/blogs/tutorials/huggingfaceRL/ppo-surrogate.jpg" alt="Surrogate Objective"></li>
</ul>
</section>
    
        
        
            
            
            
        
        <section id="the-ratio-function">


<h4 class="header-anchor-wrapper">The Ratio Function
  <a href="#the-ratio-function" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h4>

<ul>
<li>$r_t(\theta) = \frac{\pi_\theta(a_t | s_t)}{\pi_{\theta_{old}}(a_t | s_t)}$</li>
<li>The ratio function $r_t(\theta)$ measures how much the current policy $\pi_\theta(a_t | s_t)$ differs from the old policy $\pi_{\theta_{old}}(a_t | s_t)$ for the action $a_t$ taken in state $s_t$</li>
<li>If the ratio is close to 1, it means the current policy is similar to the old policy for that action.</li>
</ul>
<p><img src="/blogs/tutorials/huggingfaceRL/ratio1.jpg" alt="Ratio Function"></p>
<ul>
<li>If the ratio is greater than 1, it means the current policy is more likely to take that action compared to the old policy.</li>
<li>If the ratio is less than 1, it means the current policy is less likely to take that action compared to the old policy.</li>
<li>The ratio function is used to measure the change in the policy for the action taken at time step $t$.</li>
</ul>
<p><img src="/blogs/tutorials/huggingfaceRL/ratio2.jpg" alt="Ratio Function 2"></p>
</section>
    
        
        
            
            
            
        
        <section id="the-unclipped-objective">


<h4 class="header-anchor-wrapper">The Unclipped Objective
  <a href="#the-unclipped-objective" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h4>

<ul>
<li>The ratio function, $r_t(\theta)$, is multiplied by the advantage estimate, $A_t$, to form the unclipped objective.</li>
<li>Here the ratio function takes the place of the log-probability used in REINFORCE and Advantage Actor-Critic.
<img src="/blogs/tutorials/huggingfaceRL/unclipped1.jpg" alt="Unclipped Objective"></li>
</ul>
<p><img src="/blogs/tutorials/huggingfaceRL/unclipped2.jpg" alt="Unclipped Objective 2"></p>
</section>
    
        
        
            
            
            
        
        <section id="the-clipped-objective">


<h4 class="header-anchor-wrapper">The Clipped Objective
  <a href="#the-clipped-objective" class="header-anchor-link">
<svg
    xmlns="http://www.w3.org/2000/svg"
    width="1rem" height="1rem" viewBox="0 0 24 24" fill="none"
    stroke="currentColor" stroke-width="2" stroke-linecap="round"
    stroke-linejoin="round">
    <line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>
</svg>

</a>
</h4>

<ul>
<li>
<p>If the ratio $r_t(\theta)$ deviates too much from 1, it indicates a significant change in the policy.</p>
</li>
<li>
<p>To prevent this, we clip the ratio: we ensure that we do not have a too large policy update.</p>
</li>
<li>
<p>Two solutions:</p>
<ol>
<li>TRPO: Trust Region Policy Optimization $\rightarrow$ constrains the policy update using a KL-divergence constraint. Complicated to implement.</li>
<li>PPO: Proximal Policy Optimization $\rightarrow$ simpler to implement and computationally efficient. We use Clipped surrogate Objective function.
<img src="/blogs/tutorials/huggingfaceRL/clipped.jpg" alt="Clipped Objective"></li>
</ol>
</li>
<li>
<p>The clipped objective limits the change in the policy by clipping the ratio $r_t(\theta)$ to the range $[1 - \epsilon, 1 + \epsilon]$.</p>
</li>
<li>
<p>This prevents the policy from changing too much in a single update, leading to more stable learning.</p>
</li>
</ul>
<p><img src="/blogs/tutorials/huggingfaceRL/recap.jpg" alt="CASES"></p>
<ul>
<li>
<p>Case 1 &amp; 2, the clipping does not affect the objective because the ratio is within the clipping range.</p>
</li>
<li>
<p>Case 3 &amp; 4, the ratio is below the clipping range $1 - \epsilon$.</p>
<ul>
<li>Case 3: if the advantage is positive, we want to increase the probability of taking that action, we still update the policy and do not clip it.</li>
<li>Case 4: if the advantage is negative, we don&rsquo;t want to decrease the probability of taking that action too much, so we clip the ratio to $1 - \epsilon$. The gradient will be zero in this case and we won&rsquo;t update the policy for that action.</li>
</ul>
</li>
<li>
<p>Case 5 &amp; 6, the ratio is above the clipping range $1 + \epsilon$.</p>
<ul>
<li>Case 5: if the advantage is positive, we don&rsquo;t want to increase the probability of taking that action too much, so we clip the ratio to $1 + \epsilon$. The gradient will be zero in this case and we won&rsquo;t update the policy for that action.</li>
<li>Case 6: if the advantage is negative, we want to decrease the probability of taking that action, we still update the policy and do not clip it.</li>
</ul>
</li>
<li>
<p>We only update the policy with the unclipped objective part. When the minimum is the clipped part, the gradient will be zero and we won&rsquo;t update the policy for that action.</p>
</li>
<li>
<p>So update policy only if:</p>
<ul>
<li>The ratio is within the clipping range.</li>
<li>The ratio is outside the clipping range but the advantage leads to getting closer to the range:
<ul>
<li>Ratio &lt; $1 - \epsilon$ and advantage &gt; 0</li>
<li>Ratio &gt; $1 + \epsilon$ and advantage &lt; 0</li>
</ul>
</li>
</ul>
</li>
<li>
<p>The final Clipped Surrogate Objective function for PPO Actor -Critic is: combination of Clipped Surrogate Objective, Value Loss Function, and Entropy Bonus.</p>
</li>
</ul>
<p><img src="/blogs/tutorials/huggingfaceRL/ppo-objective.jpg" alt="PPO Objective"></p>
</section>
    
</article>
</div>


                
                    
                

                
            </div>
        </main>
</body>
</html>
